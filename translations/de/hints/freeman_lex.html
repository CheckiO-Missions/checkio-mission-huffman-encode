<body data-author="freeman_lex">
<div class="question-answer">
    <div class="question">
        Ich habe keine Ahnung, wie ich mit der L√∂sung dieser Aufgabe beginnen soll.
    </div>
    <div class="answer">
        <p>
            Fangen Sie eine Idee üí°! Erstellen Sie eine Folge von Tupeln, wobei jedes Tupel aus einem eindeutigen Zeichen und seiner H√§ufigkeit besteht. Dann entfernen Sie die beiden Tupel mit den niedrigsten Frequenzen, f√ºgen sie zusammen und setzen das so entstandene Tupel wieder in die Sequenz ein. Wiederholen Sie den Vorgang, bis nur noch ein Element √ºbrig ist. Aktualisieren Sie dabei bei jedem Schritt den Pr√§fixcode f√ºr jedes Zeichen mit "0" oder "1", je nach Knotenpriorit√§t in einem anderen W√∂rterbuchobjekt mit Buchstaben und ihren Pr√§fixcodes. Als letzten Schritt erstellen Sie eine neue Zeichenfolge mit Pr√§fixcodes anstelle von Buchstaben und geben diese zur√ºck, wobei Sie die Reihenfolge beibehalten.
        </p>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Ok, womit soll ich anfangen?
    </div>
    <div class="answer">
        <p>
            Es gibt spezielle Standardmodule, die Berechnungen effizienter machen. Lassen Sie uns diese vor der Funktionsdeklaration verwenden. <b class="code">Counter</b> z√§hlt die H√§ufigkeiten der Elemente in der Sequenz und gibt ein <b class="code">Counter</b> Objekt zur√ºck, das eigentlich ein W√∂rterbuch der Elemente und ihrer H√§ufigkeiten ist. <a target="_blank" href="https://docs.python.org/3/library/heapq.html">heapq</a> bietet einen effizienten Priorit√§tswarteschlangen-Algorithmus und das ist genau das, was Sie brauchen! Lesen Sie mehr √ºber seine Methoden.
        </p>
        <pre class="brush: python">
from collections import Counter
import heapq
        </pre>
        <p>
            Erstellen Sie ein solches <b class="code">Counter</b> Objekt mit der Unterklasse <a target="_blank" href="https://docs.python.org/3/library/collections.html#collections.Counter">Counter()</a>.
        </p>
        <pre class="brush: python">
counter = Counter(text)
        </pre> 
        <p>
            Danach m√ºssen Sie auch ein W√∂rterbuch initialisieren, um die Huffman-Codes f√ºr jedes Zeichen zu speichern. Dazu verwenden Sie die <a target="_blank" href="https://www.w3schools.com/python/python_for_loops.asp">for</a> Schleife und das W√∂rterbuchverst√§ndnis, das dasselbe ist wie <a target="_blank" href="https://www.w3schools.com/python/python_lists_comprehension.asp">list comprehension</a>, aber in W√∂rterbuchklammern geschrieben wird.
        </p>
        <pre class="brush: python">
letters = {let: "" for let in counter}
        </pre>  
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Das sind schon eine Menge Informationen... was tun Sie als n√§chstes?
    </div>
    <div class="answer">
        <p>
            Sie haben ein <b class="code">Counter</b> Objekt mit Zeichen und deren H√§ufigkeit, aber Sie brauchen eine Liste von Tupeln mit umgekehrter Reihenfolge der Werte: (H√§ufigkeit, Zeichen), um sie sp√§ter in der Priorit√§tswarteschlange (nach H√§ufigkeit) zu verwenden. Verwenden Sie List Comprehension und die Methode <a target="_blank" href="https://www.w3schools.com/python/ref_dictionary_items.asp">dict.items()</a>, um die Liste zu erstellen.
        </p>
        <pre class="brush: python">
queue = [(freq, char) for char, freq in counter.items()]
        </pre>
        <p>
            Definieren wir hier einen Sonderfall, in dem nur ein Zeichen in dem gegebenen Text vorkommt (L√§nge der Warteschlange gleich 1) und geben Sie sofort eine Zeichenkette mit "0" zur√ºck, die <b class="code">freq</b> wiederholt wird
        </p>
        <pre class="brush: python">
if len(queue) == 1:
    return "0" * queue[0][0]
        </pre>
        <p>
            Jetzt k√∂nnen Sie mit der Hauptarbeit fortfahren!
        </p>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Ja...aber ich brauche noch Hilfe.
    </div>
    <div class="answer">
        <p>
            Jetzt m√ºssen Sie <b class="code">queue</b> in einen Haufen umwandeln, der Ihnen die M√∂glichkeit gibt, Elemente entsprechend ihrer Priorit√§t (H√§ufigkeit der Zeichen) effizient zu verschieben und zu l√∂schen.
        </p>
        <pre class="brush: python">
heapq.heapify(queue)
        </pre>
        <p>
            Sie m√ºssen weitere Operationen durchf√ºhren, bis nur noch ein Element in <b class="code">queue</b> √ºbrig ist.
        </p>
        <pre class="brush: python">
while len(queue)> 1:
    ...
        </pre>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Ich brauche einen Hinweis, wie man zwei Elemente in ein einziges umwandelt.
    </div>
    <div class="answer">
        <p>
            Ziehen Sie die beiden Knoten (eine Zeichenkette) mit den niedrigsten Frequenzen aus der <b class="code">queue</b>.
        </p>
        <pre class="brush: python">
freq1, node1 = heapq.heappop(queue)
freq2, node2 = heapq.heappop(queue)
        </pre>
        <p>
            F√ºhren Sie nun die beiden Knoten und ihre Frequenzen zusammen und schieben Sie sie zur√ºck in den <b class="code">queue</b>. Er wird automatisch in der Reihenfolge seiner Frequenz im Heap platziert!
        </p>
        <pre class="brush: python">
freq1, node1 = heapq.heappop(queue)
freq2, node2 = heapq.heappop(queue)
...
heapq.heappush(queue, (freq1 + freq2, node1 + node2))
        </pre>
        <p>
            Beachten Sie, dass zwischen diesen beiden Schritten noch weitere liegen!
        </p>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Ich verstehe. Helfen Sie mir, diese Schritte zu schreiben.
    </div>
    <div class="answer">
        <p>
            Sie haben ein W√∂rterbuch mit Buchstaben und ihren Codes erstellt. Bei jedem Schritt der Verbindung zweier Knoten m√ºssen Sie den Code f√ºr jedes Zeichen in beiden Knoten aktualisieren! Weisen Sie also allen Zeichen im ersten Knoten den Code '0' und allen Zeichen im zweiten Knoten den Code '1' zu, entsprechend der Beschreibung der Aufgabe. Verwenden Sie dazu die <b class="code">for</b> Schleife, W√∂rterbuchschl√ºssel und String-Verkettung.
        </p>
        <pre class="brush: python">
for char in node1:
    letters[char] = "0" + letters[char]

for char in node2:
    letters[char] = "1" + letters[char]
        </pre>
        <p>Wenn nur noch ein Element in <b class="code">queue</b> verbleibt, sind Sie bereit, den angegebenen Text zu kodieren!</p>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Wie macht man das?
    </div>
    <div class="answer">
        <p>
            Erzeugen Sie die kodierte Darstellung des Textes, indem Sie die Codes der einzelnen Zeichen mit Hilfe der <b class="code">for</b> Schleife, des Listenverst√§ndnisses, der W√∂rterbuchschl√ºssel und der <a target="_blank" href="https://www.w3schools.com/python/ref_string_join.asp">str.join()</a> Methode verketten. 
        </p>
        <pre class="brush: python">
encoded_text = ''.join(letters[char] for char in text)
        </pre>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Wie sollte also meine endg√ºltige L√∂sung aussehen?
    </div>
    <div class="answer">
        <p>
            Sie m√ºssen nur alle vorherigen Hinweise zusammenf√ºhren, Ihren Code in einen Funktionsausdruck verpacken und kodierten Text zur√ºckgeben. Die Verwendung von Typ-Hinweisen f√ºr Eingabe- und Ausgabedaten wird dringend empfohlen.
        </p>
        <p>Hier ist die gesamte L√∂sung:</p>
        <div class="spoiler">
        <pre class="brush: python">
from collections import Counter
import heapq

def huffman_encode(text: str) -> str:

    counter = Counter(text)
    letters = {let: "" for let in counter}
    queue = [(freq, char) for char, freq in counter.items()]
    if len(queue) == 1:
        return "0" * queue[0][0]
    heapq.heapify(queue)
    while len(queue)> 1:
        freq1, node1 = heapq.heappop(queue)
        freq2, node2 = heapq.heappop(queue)
        for char in node1:
            letters[char] = "0" + letters[char]
        for char in node2:
            letters[char] = "1" + letters[char]
        heapq.heappush(queue, (freq1 + freq2, node1 + node2))
    encoded_text = ''.join(letters[char] for char in text)

    return encoded_text
        </pre>
        </div>
        <p>Klicken Sie auf <b>Best Solutions</b> im Men√º Mission und sehen Sie sich viele andere interessante L√∂sungen an!</p>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Vielen Dank! Ich wei√ü und verstehe jetzt mehr! Alles funktioniert einwandfrei!
    </div>
    <div class="answer">
        Freut mich zu h√∂ren üëç!
    </div>
</div>
</body>