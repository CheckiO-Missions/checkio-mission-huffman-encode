<body data-author="freeman_lex">
<div class="question-answer">
    <div class="question">
        Je n'ai aucune id√©e de la mani√®re de commencer √† r√©soudre cette mission.
    </div>
    <div class="answer">
        <p>
            Attrapez une id√©e üí°! Cr√©er une s√©quence de tuples, o√π chaque tuple est compos√© d'un caract√®re unique et de sa fr√©quence. Puis retirer deux tuple avec les fr√©quences les plus basses, les joindre et remettre le tuple r√©sultant dans la s√©quence. R√©p√©tez l'op√©ration jusqu'√† ce qu'il ne reste plus qu'un seul √©l√©ment. Ce faisant, √† chaque √©tape, mettez √† jour le code pr√©fixe de chaque caract√®re avec "0" ou "1" en fonction de la priorit√© du n≈ìud dans un autre objet dictionnaire avec les lettres et leurs codes pr√©fixes. En derni√®re √©tape, cr√©ez et renvoyez une nouvelle cha√Æne avec des codes de pr√©fixe au lieu de lettres, en conservant l'ordre.
        </p>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Ok, par quoi dois-je commencer?
    </div>
    <div class="answer">
        <p>
            Il existe des modules standard sp√©ciaux qui rendent les calculs plus efficaces. Utilisons-les avant de d√©clarer une fonction. <b class="code">Counter</b> compte les fr√©quences des √©l√©ments de la s√©quence et renvoie un objet <b class="code">Counter</b>, qui est en fait un dictionnaire d'√©l√©ments et de leurs fr√©quences. <a target="_blank" href="https://docs.python.org/3/library/heapq.html">heapq</a> offre un algorithme efficace de file d'attente prioritaire et c'est exactement ce dont vous avez besoin! D√©couvrez ses m√©thodes.
        </p>
        <pre class="brush: python">
from collections import Counter
import heapq
        </pre>
        <p>
            Cr√©ez un tel objet <b class="code">Counter</b> avec la sous-classe <a target="_blank" href="https://docs.python.org/3/library/collections.html#collections.Counter">Counter()</a>.
        </p>
        <pre class="brush: python">
counter = Counter(text)
        </pre> 
        <p>
            Ensuite, vous devez √©galement initialiser un dictionnaire pour stocker les codes de Huffman pour chaque caract√®re, en utilisant la boucle <a target="_blank" href="https://www.w3schools.com/python/python_for_loops.asp">for</a> et la compr√©hension du dictionnaire, qui est la m√™me que <a target="_blank" href="https://www.w3schools.com/python/python_lists_comprehension.asp">list comprehension</a> mais √©crite √† l'int√©rieur des crochets du dictionnaire.
        </p>
        <pre class="brush: python">
letters = {let: "" for let in counter}
        </pre>  
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Cela fait d√©j√† beaucoup d'informations... que faire ensuite?
    </div>
    <div class="answer">
        <p>
            Vous avez un objet <b class="code">Counter</b> contenant des caract√®res et leurs fr√©quences, mais vous avez besoin d'une liste de tuples avec l'ordre oppos√© des valeurs: (fr√©quence, caract√®re) pour les utiliser plus tard dans la file d'attente prioritaire (par fr√©quence). Utilisez la compr√©hension de liste et la m√©thode <a target="_blank" href="https://www.w3schools.com/python/ref_dictionary_items.asp">dict.items()</a> pour cr√©er la liste.
        </p>
        <pre class="brush: python">
queue = [(freq, char) for char, freq in counter.items()]
        </pre>
        <p>
            D√©finissons ici un cas particulier, lorsqu'il n'y a qu'un seul caract√®re dans le texte donn√© (longueur de la file d'attente √©gale √† 1) et renvoyons imm√©diatement une cha√Æne de "0" r√©p√©t√©e <b class="code">freq</b> fois
        </p>
        <pre class="brush: python">
if len(queue) == 1:
    return "0" * queue[0][0]
        </pre>
        <p>
            Vous pouvez maintenant passer au travail principal!
        </p>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Oui, mais j'ai encore besoin d'aide.
    </div>
    <div class="answer">
        <p>
            Vous devez maintenant convertir <b class="code">queue</b> en tas, ce qui vous permet de pousser et de retirer efficacement les √©l√©ments en fonction de leur priorit√© (fr√©quence des caract√®res).
        </p>
        <pre class="brush: python">
heapq.heapify(queue)
        </pre>
        <p>
            Vous devez effectuer d'autres op√©rations jusqu'√† ce qu'il ne reste plus qu'un seul √©l√©ment dans le <b class="code">queue</b>.
        </p>
        <pre class="brush: python">
while len(queue)> 1:
    ...
        </pre>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        J'ai besoin d'un indice pour convertir deux √©l√©ments en un seul.
    </div>
    <div class="answer">
        <p>
            Retirez les deux n≈ìuds (une cha√Æne) ayant les fr√©quences les plus basses du site <b class="code">queue</b>.
        </p>
        <pre class="brush: python">
freq1, node1 = heapq.heappop(queue)
freq2, node2 = heapq.heappop(queue)
        </pre>
        <p>
            Fusionnez maintenant les deux n≈ìuds et leurs fr√©quences et repoussez-les dans le <b class="code">queue</b>. Ils sont plac√©s dans le tas dans l'ordre de leur fr√©quence automatiquement!
        </p>
        <pre class="brush: python">
freq1, node1 = heapq.heappop(queue)
freq2, node2 = heapq.heappop(queue)
...
heapq.heappush(queue, (freq1 + freq2, node1 + node2))
        </pre>
        <p>
            Remarquez qu'il y a des √©tapes suppl√©mentaires entre ces deux n≈ìuds!
        </p>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Je vois. Aidez-moi √† √©crire ces √©tapes.
    </div>
    <div class="answer">
        <p>
            Vous avez cr√©√© un dictionnaire avec des lettres et leurs codes. √Ä chaque √©tape de la jonction de deux n≈ìuds, vous devez mettre √† jour le code de chaque caract√®re dans les deux n≈ìuds! Attribuez donc le code "0" √† tous les caract√®res du premier n≈ìud et le code "1" √† tous les caract√®res du second n≈ìud, conform√©ment √† la description de la mission. Pour ce faire, utilisez la boucle <b class="code">for</b>, les cl√©s du dictionnaire et la concat√©nation de cha√Ænes de caract√®res.
        </p>
        <pre class="brush: python">
for char in node1:
    letters[char] = "0" + letters[char]

for char in node2:
    letters[char] = "1" + letters[char]
        </pre>
        <p>Lorsqu'il ne reste plus qu'un seul √©l√©ment dans <b class="code">queue</b>, vous √™tes pr√™t √† encoder le texte donn√©!</p>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Comment proc√©der?
    </div>
    <div class="answer">
        <p>
            G√©n√©rez la repr√©sentation cod√©e du texte en concat√©nant les codes de chaque caract√®re, en utilisant la boucle <b class="code">for</b>, la compr√©hension de liste, les cl√©s de dictionnaire et la m√©thode <a target="_blank" href="https://www.w3schools.com/python/ref_string_join.asp">str.join()</a>. 
        </p>
        <pre class="brush: python">
encoded_text = ''.join(letters[char] for char in text)
        </pre>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Alors, √† quoi devrait ressembler ma solution finale?
    </div>
    <div class="answer">
        <p>
            Il vous suffit de joindre tous les indices pr√©c√©dents, d'envelopper votre code dans une expression de fonction et de renvoyer un texte cod√©. Il est fortement recommand√© d'utiliser des indications de type pour les donn√©es d'entr√©e et de sortie.
        </p>
        <p>Voici la solution compl√®te:</p>
        <div class="spoiler">
        <pre class="brush: python">
from collections import Counter
import heapq

def huffman_encode(text: str) -> str:

    counter = Counter(text)
    letters = {let: "" for let in counter}
    queue = [(freq, char) for char, freq in counter.items()]
    if len(queue) == 1:
        return "0" * queue[0][0]
    heapq.heapify(queue)
    while len(queue)> 1:
        freq1, node1 = heapq.heappop(queue)
        freq2, node2 = heapq.heappop(queue)
        for char in node1:
            letters[char] = "0" + letters[char]
        for char in node2:
            letters[char] = "1" + letters[char]
        heapq.heappush(queue, (freq1 + freq2, node1 + node2))
    encoded_text = ''.join(letters[char] for char in text)

    return encoded_text
        </pre>
        </div>
        <p>Cliquez sur <b>Best Solutions</b> dans le menu mission et d√©couvrez de nombreuses autres solutions int√©ressantes!</p>
    </div>
</div>
<div class="question-answer">
    <div class="question">
        Merci beaucoup! Je sais et je comprends mieux maintenant! Tout fonctionne bien!
    </div>
    <div class="answer">
        Heureux de l'apprendre üëç!
    </div>
</div>
</body>